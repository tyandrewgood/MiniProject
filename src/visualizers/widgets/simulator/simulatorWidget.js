/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Nov 27 2020 10:05:20 GMT-0500 (Eastern Standard Time).
 */

//define(['css!./styles/simulatorWidget.css'], function () {
//    'use strict';


var zeroCount = 0;
var placesLength = 0;


define(['jointjs', 'css!./styles/simulatorWidget.css', 'css!jointjscss'], function (jointjs) {
    'use strict';

    var WIDGET_CLASS = 'simulator';

    function simulatorWidget(logger, container, client) {
        this._logger = logger.fork('Widget');

        this._el = container;
        this._client = client;
        this.nodes = {};


        this.places = {};
        this.trans = {};
        this.edges = {};
        this.inPlaces = {};
        this.outPlaces = {};
 

        this._initialize();


        this._logger.debug('ctor finished');
    }

    simulatorWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);
    
        this._graph = null;
        this._paper = null;

        this.xVal = 100;
        this.yVal = 100;
        this.visited = [];
        this.visitedLength = 0;
        this.count = 0;


        this.countTran = 0;
        this.xValTran = 225;
        this.yValTran = 100;


        this._graph = new jointjs.dia.Graph;
        this._paper = new jointjs.dia.Paper({
        
            el: $(this._el), 
            width: width,
            height: height,
            gridSize: 1,
            defaultAnchor: {name: 'perpendicular'}, 
            defaultConnectionPoint: {name: 'boundary'},
            model:this._graph
        });
        

        this._paper.setInteractivity(false);
        this._paper.removeTools();

        // Place Example from lectue
        this.placeObj = jointjs.dia.Element.define('petri.Place', {
            attrs: {
                circle: {
                    r: 25, 
                    'stroke-width': 3, 
                    stroke: '#000000',
                    fill: '#f2f2f2', 
                    cursor: 'pointer',
                }, 
                label: {
                    textVerticalAnchor: 'middle',
                    textAnchor: 'middle',
                    refX: '50%',
                    refY: '-30',
                    ref: 'circle',
                    fontSize: 7,
                    cursor: 'pointer'
                }, 
                text: {
                    textVerticalAnchor: 'middle',
                    textAnchor: 'middle',
                    refX: '50%',
                    refY: '-30',
                    ref: 'circle',
                    fontSize: 14,
                    cursor: 'pointer', 
                }, 
                '.tokens > circle': {
                    'fill': '#7a7e9b'
                }
            },      
            tokens: 0
        }, {
            markup: [{
                tagName: 'circle', 
                selector: 'circle'
            }, {
                tagName: 'label', 
                selector: 'label'
            },{
                tagName: 'text', 
                selector: 'text',
            }]
        });

        // From JointJS Standard Link Library 
        this.linkObj = jointjs.dia.Link.define('standard.Link', {
            attrs: {
                line: {
                    connection: true,
                    stroke: '#333333',
                    strokeWidth: 2,
                    strokeLinejoin: 'round',
                    targetMarker: {
                        'type': 'path',
                        'd': 'M 10 -5 0 0 10 5 z'
                    }
                },
                wrapper: {
                    connection: true,
                    strokeWidth: 10,
                    strokeLinejoin: 'round'
                }
            }
        }, {
            markup: [{
                tagName: 'path',
                selector: 'wrapper',
                attributes: {
                    'fill': 'none',
                    'cursor': 'pointer',
                    'stroke': 'transparent'
                }
            }, {
                tagName: 'path',
                selector: 'line',
                attributes: {
                    'fill': 'none',
                    'pointer-events': 'none'
                }
            }]
        });


        /*
        // Create a dummy header
        this._el.append('<h3>simulator Events:</h3>');

        // Registering to events can be done with jQuery (as normal)
        this._el.on('dblclick', function (event) {
            event.stopPropagation();
            event.preventDefault();
            self.onBackgroundDblClick();
        });

        */

        this._paper.on('element:pointerdown', function(elementView) {
            var currentElement = elementView.model;
            var transition = self.getClicked(currentElement.id);
            if (transition != undefined && transition.enabled) {
                var destinations = self.findDest(transition);
                for (i = 0; i < destinations.length; i++) {
                    var curr = destinations[i];
                    self.findPlace(curr); // increment the destinations counter by one
                }  
                var source = self.findSource(transition);  
                self.findPlace2(source)          
            }  else {
                console.log('Transition Not Enabled, Try a different one')
            }             
        })
    };

    simulatorWidget.prototype.getClicked = function(id) {
        var res = undefined;
        for (var temp of Object.values(this.trans)) {
            if (temp.edgeNode.id == id) {
                res = temp;
            }
        }
        return res;
    };

    simulatorWidget.prototype.findDest = function(transition) {
        var res = [];
        for (const desc of Object.keys(this.edges)) {
            var temp = this.edges[desc];
            if (temp.source == transition.id) {
                res.push(temp.dest)
            }
        }
        return res;
    };

    simulatorWidget.prototype.findSource = function(transition) {
        var res = [];
        for (const desc of Object.keys(this.edges)) {
            var temp = this.edges[desc];
            if (temp.dest == transition.id) {
                res.push(temp.source)
            }
        }
        return res;
    };

    simulatorWidget.prototype.findPlace = function(current) {
        for (const desc of Object.keys(this.places)) {
            var tempPlace = this.places[desc];
            if (tempPlace.id == current) {
                console.log('Current tokens of destination = ' + tempPlace.tokens)
                tempPlace.tokens += 1;
                tempPlace.name =  tempPlace.id + '  (' + tempPlace.tokens + ')'
                console.log('Current tokens increased by one, new count = ' + tempPlace.tokens)
                // it does increase
            }
        }
    };

    simulatorWidget.prototype.findPlace2 = function(source) {
        for (const desc of Object.keys(this.places)) {
            var tempPlace = this.places[desc];
            if (tempPlace.id == source) {
                console.log('Current tokens of source = ' + tempPlace.tokens)
                tempPlace.tokens -= 1;
                tempPlace.name =  tempPlace.id + '  (' + tempPlace.tokens + ')'
                console.log('Current tokens decreased by one, new count = ' +  tempPlace.tokens)
                // it does increase
            }
        }
    };

    simulatorWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...'); 
        if (this._paper) {
            this._paper.setDimensions(width, height);
            this._paper.scaleContentToFit();
        }
    };

    simulatorWidget.prototype.addNode = function (desc) {     
        if (desc) {
            var current = this._client.getNode(desc.id);
            const pn = jointjs.shapes.pn;
            if (Number.isInteger(desc.marking)) { 
                // We know only places have marking, otherwise it will return undefined
                const place = new this.placeObj({
                    position: current.getRegistry('position'),
                    attrs: {
                        text: {
                            text: desc.name + '  (' + desc.marking + ')'
                        }, 
                        label: {
                            label: desc.marking.toString()
                        }
                    }, 
                    tokens: desc.marking
                });
                if (desc.marking == 0) {
                    zeroCount = zeroCount + 1;
                }
                placesLength = placesLength + 1;
                this.places[desc.id] = {
                    id: desc.id,
                    edgeNode: place,
                    tokens: desc.marking
                }
                this._graph.addCell([place]);
            } else if (desc.isConnection) {
                // Only inPlace and outPlace are connections
                const source = current.getPointerId('src');
                const dest = current.getPointerId('dst');
                if (current.isInstanceOf('InPlace')) {
                    this.inPlaces[desc.id] = {
                        id: desc.id
                    }
                }
                if (current.isInstanceOf('OutPlace')) {
                    this.outPlaces[desc.id] = {
                        id: desc.id
                    }
                }
                this.edges[desc.id] = {
                    source, dest
                };
            } else if (current.isInstanceOf('Transition')){ 
                const pos = current.getRegistry('position');
                const transition1 = new pn.Transition({
                    position: pos,
                    attrs: {
                        '.label': {
                            'text': desc.name,
                            'fill': '#000000'
                        }, 
                        '.root':{
                            'fill': '#f2f2f2',
                            'stroke': '#000000'
                        }
                    }
                });
                this.trans[desc.id] = {
                    id: desc.id,
                    edgeNode: transition1,
                    enabled: false
                }
                this._graph.addCell([transition1]);
            }
            this.makeLinks();
            this.zeroMarkingCheck();
            this.deadlockCheck();
        }
    };

    simulatorWidget.prototype.makeLinks = function() {
        for (const desc of Object.keys(this.edges)) {
            const temp = this.edges[desc];
            var source = null;
            if (temp.source in this.places) {
                source = this.places[temp.source];
            } else if (temp.source in this.trans) {
                source = this.trans[temp.source];
            }
            if (source != null) {
                var dest = null;
                if (temp.dest in this.places) {
                    dest = this.places[temp.dest];
                } else if (temp.dest in this.trans) {
                    dest = this.trans[temp.dest];
                }
                if (dest != null) {
                    //const link2 = new jointjs.shapes.standard.Link();
                    var link2 = null;               
                    if (source.tokens == 0 || source.tokens == undefined) {
                        link2 = new this.linkObj({
                            attrs: {
                                line: {
                                    stroke: '#333333'
                                }
                            }, 
                        });
                    } else {
                        link2 = new this.linkObj({
                            attrs: {
                                line: {
                                    stroke: '#90EE90'
                                }
                            }, 
                        });
                        //console.log(dest)
                        dest.enabled = true;
                        //console.log(dest)
                    }
                    link2.source(source.edgeNode, {
                        anchor: {
                            name: 'modelCenter'
                        }
                    });
                    link2.target(dest.edgeNode, {
                        anchor: {
                            name: 'modelCenter'
                        }
                    });  
                    this._graph.addCell([link2]);
                }
            }
        }
    };

    simulatorWidget.prototype.zeroMarkingCheck = function() {
        if (placesLength == zeroCount && placesLength != 0) {
            for (var transition of Object.values(this.trans)) {
                transition.edgeNode.attr('.root/fill', '#FFFF00')
            }
        } else {
            for (var transition of Object.values(this.trans)) {
                transition.edgeNode.attr('.root/fill', '#f2f2f2')
            }
        }
    };

    simulatorWidget.prototype.deadlockCheck = function() {
        var notDeadlock = false;
        for (const desc of Object.keys(this.edges)) {
            const temp = this.edges[desc];
            var source = null;
            if (temp.source in this.places) {
                source = this.places[temp.source];
            } else if (temp.source in this.trans) {
                source = this.trans[temp.source];
            }
            if (source != null) {
                var dest = null;
                if (temp.dest in this.places) {
                    dest = this.places[temp.dest];
                } else if (temp.dest in this.trans) {
                    dest = this.trans[temp.dest];
                }
                if (dest != null) {
                    if (source.tokens != 0 && source.tokens != undefined) {
                        notDeadlock = true;
                    }
                }
            }
        }
        if (notDeadlock) {
            for (var transition of Object.values(this.trans)) {
                transition.edgeNode.attr('.root/fill', '#f2f2f2')
            }
        } else {
            for (var transition of Object.values(this.trans)) {
                transition.edgeNode.attr('.root/fill', '#FFFF00')
            }
        }
    }
   
    simulatorWidget.prototype.removeNode = function (gmeId) {
        var desc = this.nodes[gmeId];
        this._el.append('<div>Removing node "' + desc.name + '"</div>');
        delete this.nodes[gmeId];
    };

    simulatorWidget.prototype.updateNode = function (desc) {
        if (desc) {
            this._logger.debug('Updating node:', desc);
            this._el.append('<div>Updating node "' + desc.name + '"</div>');
        }
    };
    

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    simulatorWidget.prototype.onNodeClick = function (/*id*/) {
        // This currently changes the active node to the given id and
        // this is overridden in the controller.
    };

    simulatorWidget.prototype.onBackgroundDblClick = function () {
        this._el.append('<div>Background was double-clicked!!</div>');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    simulatorWidget.prototype.destroy = function () {
    };

    simulatorWidget.prototype.onActivate = function () {
        this._logger.debug('simulatorWidget has been activated');
    };

    simulatorWidget.prototype.onDeactivate = function () {
        this._logger.debug('simulatorWidget has been deactivated');
    };

    return simulatorWidget;
});
